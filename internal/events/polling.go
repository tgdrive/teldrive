package events

import (
	"context"
	"time"

	"go.uber.org/zap"
	"gorm.io/gorm"

	"github.com/tgdrive/teldrive/pkg/models"
)

// PollingBroadcaster implements EventBroadcaster using polling for single-instance setups
type PollingBroadcaster struct {
	*baseBroadcaster
	pollInterval time.Duration
	lastPollTime time.Time
}

// NewPollingBroadcaster creates a new polling-based event broadcaster for single-instance setups
func NewPollingBroadcaster(ctx context.Context, db *gorm.DB, pollInterval time.Duration, config BroadcasterConfig, logger *zap.Logger) *PollingBroadcaster {
	if pollInterval <= 0 {
		pollInterval = 10 * time.Second // Default: 10 seconds
	}

	ctx, cancel := context.WithCancel(ctx)
	b := &PollingBroadcaster{
		baseBroadcaster: newBaseBroadcaster(db, logger, ctx, cancel, config),
		pollInterval:    pollInterval,
		lastPollTime:    time.Now().Add(-pollInterval), // Start from current time minus interval
	}

	b.wg.Add(1)
	go b.poll()

	logger.Debug("events.polling_broadcaster_created",
		zap.Duration("poll_interval", pollInterval))
	return b
}

// poll periodically checks the database for new events
func (b *PollingBroadcaster) poll() {
	defer b.wg.Done()

	ticker := time.NewTicker(b.pollInterval)
	defer ticker.Stop()

	for {
		select {
		case <-b.ctx.Done():
			return
		case <-ticker.C:
			b.checkForNewEvents()
		}
	}
}

// checkForNewEvents queries the database for events since last poll
func (b *PollingBroadcaster) checkForNewEvents() {
	now := time.Now()

	// Query events from all users (limit to prevent memory issues if server was down)
	var events []models.Event
	if err := b.db.Where("created_at > ?", b.lastPollTime).Order("created_at ASC").Limit(1000).Find(&events).Error; err != nil {
		b.logger.Error("events.poll_query_failed", zap.Error(err))
		return
	}

	b.lastPollTime = now

	if len(events) == 0 {
		return
	}

	b.logger.Debug("events.poll_found",
		zap.Int("count", len(events)))

	// Broadcast to subscribers with deduplication
	for _, evt := range events {
		// Skip if already processed (deduplication)
		if !b.shouldProcess(evt.ID) {
			continue
		}
		b.broadcast(evt)
	}
}

// Record saves an event to the database (no immediate broadcast - let poll discover it)
func (b *PollingBroadcaster) Record(eventType EventType, userID int64, source *models.Source) {
	evt := createEvent(eventType, userID, source)
	// ID is already generated by createEvent()

	// Only save to DB - poll() will discover and broadcast it
	// This prevents duplicate broadcasts
	select {
	case b.dbWorkerCh <- evt:
		// Queued for DB write
	default:
		b.logger.Warn("events.db_queue_full",
			zap.Int64("user_id", userID),
			zap.String("type", string(eventType)))
	}
}

// Shutdown gracefully stops the broadcaster
func (b *PollingBroadcaster) Shutdown() {
	b.logger.Info("events.polling_broadcaster_shutting_down")
	b.cancel()

	// Wait for workers with timeout to prevent hanging
	done := make(chan struct{})
	go func() {
		b.wg.Wait()
		close(done)
	}()

	select {
	case <-done:
		// Normal shutdown
	case <-time.After(5 * time.Second):
		b.logger.Warn("events.shutdown_timeout")
	}

	b.logger.Info("events.polling_broadcaster_shutdown_complete")
}
